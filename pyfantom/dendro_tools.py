import numpy as np
import pandas as pd
from plotly.tools import FigureFactory as FF
from collections import Counter


class DendrogramNode:
    """
    Simple datastructure representing a Node in the Dendrogram Tree
    """

    def __init__(self, coords, left, right):
        self.coords = coords
        self._left = left
        self._right = right
        self.super_terms = Counter()

    @property
    def left(self):
        return self._left

    @property
    def right(self):
        return self._right

    def add_super_term(self, obo_id):
        self.super_terms[obo_id] += 1


class DendrogramTree:
    """
    Here, we are turning data_items from the dendrogram visualisation into hashable coordinates.
    The dendrogram consists of elements of |^|. Left coordinate refers to the bottom left end,
    right to the bottom right end respectively. Parent refers to the top middle.
    Coordinates are rounded to avoid numerical problems.
    The Coordinates are relative to the matplotlib cooridnate system used to generate the dendrogram.
    """

    def __init__(self, plotly_dendro, corr_mat_df):
        """
        Construct a Tree (Parent/Child relations) from a dendrogram coordinates

        Args:
            plotly_dendro: Dendrogram generated by plotyly FigureFactory
            corr_mat: The correlation matrix the Dendrogram was created from as a (named) Pandas DataFrame

        >>> np.random.seed(42)
        >>> corr_mat_df = pd.DataFrame(np.random.random((10, 10)))
        >>> dendro = FF.create_dendrogram(corr_mat_df.as_matrix())
        >>> dt = DendrogramTree(dendro, corr_mat_df)

        """
        self.ref_dict = dict()
        self.dendro = plotly_dendro
        self.corr_mat_df = corr_mat_df
        for data_item in self.dendro['data']:
            self.add_item(data_item)
        self.check_consistency()

    @staticmethod
    def get_test_tree():
        """Setup a (seeded) random dendrogram tree for doctests"""
        np.random.seed(42)
        names = list("ABCDEFGHIJ")
        corr_mat_df = pd.DataFrame(np.random.random((10, 10)),
                                   columns=names, index=names)
        dendro = FF.create_dendrogram(corr_mat_df.as_matrix())
        return DendrogramTree(dendro, corr_mat_df)

    @staticmethod
    def rnd(x, digits=4):
        """round a tuple"""
        return tuple((round(float(y), digits) for y in x))

    @staticmethod
    def get_left_coordinate(data_item):
        return DendrogramTree.rnd((data_item["x"][0], data_item["y"][0]))

    @staticmethod
    def get_right_coordinate(data_item):
        return DendrogramTree.rnd((data_item["x"][-1], data_item["y"][-1]))

    @staticmethod
    def get_parent_coordinate(data_item):
        assert data_item["y"][1] == data_item["y"][2]
        return DendrogramTree.rnd((np.mean(DendrogramTree.rnd(data_item["x"][1:3], 6)), data_item["y"][1]))

    def leaf_to_obo(self, leaf_coords):
        """
        Turn coordinates of a leaf into the respective obo id.
        """
        layout = self.dendro['layout']['xaxis']
        i = layout['tickvals'].index(leaf_coords[0])
        leaf_id = int(layout['ticktext'][i])
        return self.corr_mat_df.index[leaf_id]

    def add_item(self, data_item):
        """
        Add a data item from a plotly dendrogram.
        Extract and round the corrdinates appropriately and store them in the ref_dict.
        """
        coords = self.get_parent_coordinate(data_item)
        self.ref_dict[coords] = DendrogramNode(coords, left=self.get_left_coordinate(data_item),
                                               right=self.get_right_coordinate(data_item))

    def get_leaf_nodes(self, coords):
        """
        Get all leafs_ids (index in the array generating the dendrogram) by
        recursing through the ref_dict containing parent/child relations of
        the dendrogram elements.

        >>> dt = DendrogramTree.get_test_tree()
        >>> [x for x in dt.get_leaf_nodes((13.75, 1.4248))]
        [(5.0, 0.0), (15.0, 0.0), (25.0, 0.0), (35.0, 0.0)]
        """
        if coords[1] == 0:  # y == 0 -> leaf
            yield coords
        else:
            yield from self.get_leaf_nodes(self.ref_dict[coords].left)
            yield from self.get_leaf_nodes(self.ref_dict[coords].right)

    def find_parent(self, coords):
        """
        Get parent coordinate of a given coordinate in the dendrogram.
        Note: this method is ugly and inefficient.

        >>> dt = DendrogramTree.get_test_tree()
        >>> dt.find_parent((5.0, 0.0))
        (13.75, 1.4248)
        """
        for parent_coords, child_coords in self.ref_dict.items():
            if coords in [child_coords.left, child_coords.right]:
                return parent_coords
        if coords[1] == max(x[1] for x in self.ref_dict):  # root
            return None
        else:
            raise Exception("parent not found. ")

    def retrieve_super_terms(self, obo, delimiter_nodes):
        """
        Compute super terms for all nodes in the tree with respect to obo. (slow)

        Args:
            obo: OBOOntology
            delimiter_nodes: stopping criterion for the ontology; any terms closer
                to the root than these terms will not be considered.
        """
        for coords in self.ref_dict:
            for leaf in self.get_leaf_nodes(coords):
                obo_id = self.leaf_to_obo(leaf)
                for term in obo.super_terms(obo_id):
                    if term.id not in delimiter_nodes:
                        self[coords].add_super_term(term.id)

    def get_super_terms(self, coords):
        return self.ref_dict[coords].super_terms

    def get_filtered_super_terms(self, coords):
        """remove super terms with ratio 1.0 in that parent node, as these lead to no infomration gain. """
        super_terms = self.get_super_terms(coords)
        parent_coords = self.find_parent(coords)
        if parent_coords is not None:
            parent_super_terms = self.get_super_terms(parent_coords)
            n_leafs = sum(1 for _ in self.get_leaf_nodes(parent_coords))
            # collate list of parent super terms that match all children:
            parent_super_terms = [term for term, count in parent_super_terms.items() if count == n_leafs]
            super_terms = {term: count for term, count in super_terms.items() if term not in parent_super_terms}
        return super_terms

    def check_consistency(self):
        """check that coordinates are consistent"""
        for child_coords in self.ref_dict.values():
            left = child_coords.left
            right = child_coords.right
            if left[1] != 0:  # leafs have no entry
                assert left in self.ref_dict
            if right[1] != 0:
                assert right in self.ref_dict
        for child_coords in self.ref_dict.values():
            assert self.find_parent(child_coords.left) is not None
            assert self.find_parent(child_coords.right) is not None

    def __getitem__(self, item):
        return self.ref_dict[item]

